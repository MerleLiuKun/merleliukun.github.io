<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Ikaros の小屋</title>
  
  <subtitle>Keep You Sane</subtitle>
  <link href="https://blog.lkhardy.cn/atom.xml" rel="self"/>
  
  <link href="https://blog.lkhardy.cn/"/>
  <updated>2023-01-04T02:36:33.138Z</updated>
  <id>https://blog.lkhardy.cn/</id>
  
  <author>
    <name>Ikaros Kun</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Sentry-数据清理</title>
    <link href="https://blog.lkhardy.cn/2020/10/09/tool-sentry-clean-data/"/>
    <id>https://blog.lkhardy.cn/2020/10/09/tool-sentry-clean-data/</id>
    <published>2020-10-09T08:31:55.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>之前部署了一个 <a href="https://sentry.io/welcome/">Sentry</a> 的服务，经过一段时间运行后，产生了很多的数据记录需要进行清理。</p><h1 id="步骤如下"><a href="#步骤如下" class="headerlink" title="步骤如下"></a>步骤如下</h1><h2 id="标记数据删除"><a href="#标记数据删除" class="headerlink" title="标记数据删除"></a>标记数据删除</h2><p>可以使用 sentry 提供的 cleanup 命令执行数据清除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">root@2f6578540024:/usr/src/sentry# sentry cleanup --help</span><br><span class="line">Usage: sentry cleanup [OPTIONS]</span><br><span class="line"></span><br><span class="line">  Delete a portion of trailing data based on creation date.</span><br><span class="line"></span><br><span class="line">  All data that is older than `--days` will be deleted.  The default for this is 30 days.  In</span><br><span class="line">  the default setting all projects will be truncated but if you have a specific project you want</span><br><span class="line">  to limit this to this can be done with the `--project` flag which accepts a project ID or a</span><br><span class="line">  string with the form `org/project` where both are slugs.</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">  --days INTEGER                  Numbers of days to truncate on.  [default: 30]</span><br><span class="line">  --project TEXT                  Limit truncation to only entries from project.</span><br><span class="line">  --concurrency INTEGER           The total number of concurrent worker processes to run.</span><br><span class="line">                                  [default: 1]</span><br><span class="line">  -q, --silent                    Run quietly. No output on success.</span><br><span class="line">  -m, --model TEXT</span><br><span class="line">  -r, --router TEXT               Database router</span><br><span class="line">  -t, --timed                     Send the duration of this command to internal metrics.</span><br><span class="line">  -l, --loglevel [DEBUG|INFO|WARNING|ERROR|CRITICAL|FATAL]</span><br><span class="line">                                  Global logging level. Use wisely.</span><br><span class="line">  --logformat [human|machine]     Log line format.</span><br><span class="line">  --help                          Show this message and exit.</span><br></pre></td></tr></table></figure><p>清除 30 天前的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentry cleanup --days 30</span><br></pre></td></tr></table></figure><p><code>sentry cleanup</code> 脚本使用 <code>delete</code> 命令将 <code>PG</code> 数据库里的数据进行清理，实则仍然占据磁盘空间。</p><h2 id="清理删除的数据"><a href="#清理删除的数据" class="headerlink" title="清理删除的数据"></a>清理删除的数据</h2><p>使用命令 <code>vacuumdb</code> 将数据进行删除。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vacuumdb -U postgres -d postgres -v -f --analyze</span><br></pre></td></tr></table></figure><h2 id="设为定时任务"><a href="#设为定时任务" class="headerlink" title="设为定时任务"></a>设为定时任务</h2><p>可以使用 <code>crontab</code> 设置一个定时任务, 每月1号清理超过30天的数据</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 0 1 * *  docker exec -it onpremise_worker_1 sentry cleanup --days 30  &amp;&amp; docker exec -it onpremise_postgres_1 vacuumdb -U postgres -d postgres -v -f --analyze</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="DevOps" scheme="https://blog.lkhardy.cn/categories/DevOps/"/>
    
    
    <category term="DevOps" scheme="https://blog.lkhardy.cn/tags/DevOps/"/>
    
    <category term="Docker" scheme="https://blog.lkhardy.cn/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>mysqlclient 安装问题</title>
    <link href="https://blog.lkhardy.cn/2020/05/06/lan-python-mysqlclient-install/"/>
    <id>https://blog.lkhardy.cn/2020/05/06/lan-python-mysqlclient-install/</id>
    <published>2020-05-06T13:23:11.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>Linux 下如果已经本地安装了 <code>MySQL</code> 或者 <code>MariaDB</code> 此时可以直接使用命令安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure><p>如果没有安装，需要先准备 <code>MySQL</code> 的开发依赖库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install default-libmysqlclient-dev build-essential # Ubuntu/Debian</span><br><span class="line">sudo yum install mysql-devel # CentOS/RedHat</span><br><span class="line">sudo pacman -S libmysqlclient # Arch/Manjaro</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">　执行安装</span></span><br><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure><h1 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h1><p>MacOS 下，如果使用了 <code>Homebrew</code> 安装了 <code>MySQL</code>，可执行如下流程</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">确认在 Python 虚拟环境下</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">假设本地为 MySQL 5.7.29 版本</span></span><br><span class="line">export PATH=&quot;/usr/local/Cellar/mysql@5.7/5.7.29/bin/:$PATH&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如果安装时爆出 ld: library not found <span class="keyword">for</span> -lssl</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">需要指定 SSL 的依赖</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">但此问题已在 master 分支处理，但未合并(2020-5-6)</span></span><br><span class="line">export LDFLAGS=&quot;-L/usr/local/opt/openssl@1.1/lib&quot;</span><br><span class="line">export CPPFLAGS=&quot;-I/usr/local/opt/openssl@1.1/include&quot;</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">执行安装</span></span><br><span class="line">pip install mysqlclient</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="https://blog.lkhardy.cn/categories/python/"/>
    
    
    <category term="python" scheme="https://blog.lkhardy.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro 入门</title>
    <link href="https://blog.lkhardy.cn/2020/03/25/linux-manjaro-introduce/"/>
    <id>https://blog.lkhardy.cn/2020/03/25/linux-manjaro-introduce/</id>
    <published>2020-03-25T16:39:57.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><code>Manjaro</code> 是一款基于 <code>Arch Linux</code> 的、对用户友好、全球排名第 1 的Linux发行版, 从使用上来看，比 <code>Arch</code> 更加易用，面向的人群是新手和初级人员还有那些不愿意折腾，却又想使用 <code>Arch</code> 新特性的人群。</p><h1 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h1><h2 id="资源"><a href="#资源" class="headerlink" title="资源"></a>资源</h2><p>中文镜像地址: </p><ul><li><a href="https://mirrors.ustc.edu.cn/manjaro-cd/">中科大地址</a></li><li><a href="https://mirrors.tuna.tsinghua.edu.cn/osdn/storage/g/m/ma/manjaro/">清华大学地址</a></li></ul><p>官方镜像地址: </p><ul><li><p><a href="https://manjaro.org/download/">Manjaro Downloads</a></p><p>启动盘制作: </p></li><li><p><a href="https://rufus.ie/zh_CN.html">Rufus</a></p></li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>选择中文，根据提示一步一步安装即可，要注意如下情况：</p><ol><li>如果是独立显卡时，可能出现黑屏，在启动配置页面可以选择 <code>nofree</code> 驱动。</li><li>系统安装过程中，分区时，注意给 <code>boot</code> 分区增加一些空间，建议 1 G, 避免多内核切换时出现存储不足。</li></ol><h1 id="系统配置"><a href="#系统配置" class="headerlink" title="系统配置"></a>系统配置</h1><h2 id="软件源"><a href="#软件源" class="headerlink" title="软件源"></a>软件源</h2><p><a href="http://mirrors.ustc.edu.cn/help/manjaro.html">配置 Pacman 源</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure><p>可选择，清华源(tuna.tsinghua), 中科大源(ustc)</p><p>Pacman 常见命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syu # 同步数据包后更新系统</span><br><span class="line"></span><br><span class="line">pacman -Sy 包名 # 同步包数据库后安装。</span><br><span class="line"></span><br><span class="line">pacman -R 包名 # 删除包不删除依赖</span><br><span class="line">pacman -Rs 包名 # 删除包的同时删除不被其它包使用的依赖</span><br><span class="line">pacman -Rd 包名 # 删除包不检查依赖</span><br><span class="line"></span><br><span class="line">pacman -Ss 关键字 # 搜索含关键字的包。</span><br><span class="line">pacman -Qi 包名 # 查看有关包的信息。</span><br><span class="line"></span><br><span class="line">pacman -Sc Pacman #清理未安装的包文件</span><br></pre></td></tr></table></figure><p><a href="http://mirrors.ustc.edu.cn/help/archlinuxcn.html">配置 ArchLinuxCN 源</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/pacman.conf</span><br></pre></td></tr></table></figure><p>输入如下内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[archlinuxcn]</span><br><span class="line">SigLevel = Optional TrustedOnly</span><br><span class="line"># 清华源</span><br><span class="line">Server = https://mirrors.tuna.tsinghua.edu.cn/archlinuxcn/$arch</span><br><span class="line"># 中科大源</span><br><span class="line"># Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch</span><br></pre></td></tr></table></figure><p>导入 GPG key</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -Syyu &amp;&amp; sudo pacman -S archlinuxcn-keyring  &amp;&amp; sudo pacman -Syyu</span><br></pre></td></tr></table></figure><p><a href="https://mirror.tuna.tsinghua.edu.cn/help/AUR/">配置 AUR 源</a></p><p>之前有用 <code>yaourt</code> 作为 <code>AUR</code> 的助手工具，但是这个已经在 <code>Arch</code> <a href="https://wiki.archlinux.org/index.php/AUR_helpers_(%E7%AE%80%E4%BD%93%E4%B8%AD%E6%96%87)">官方Wiki</a>上被列为 “停止或有问题”，所以推荐使用<a href="https://github.com/Jguer/yay">yay</a>或者<a href="https://github.com/polygamma/aurman">aurman</a>等。</p><p>此处，以 <code>yay</code> 为例。</p><p>执行以下命令修改 <code>aururl</code>:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay --aururl <span class="string">&quot;https://aur.tuna.tsinghua.edu.cn&quot;</span> --save</span><br></pre></td></tr></table></figure><p>修改的配置文件位于 ~/.config/yay/config.json ，还可通过以下命令查看修改过的配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yay -P -g</span><br></pre></td></tr></table></figure><h2 id="输入法配置"><a href="#输入法配置" class="headerlink" title="输入法配置"></a>输入法配置</h2><p>可以选用 sogou 拼音输入法，google 拼音输入法，sun 拼音输入法。</p><p>安装 <code>fcitx</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx</span><br><span class="line">sudo pacman -S fcitx-sogoupinyin</span><br><span class="line">sudo pacman -S fcitx-configtool</span><br></pre></td></tr></table></figure><p>设置环境变量文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.pam_environment</span><br></pre></td></tr></table></figure><p>添加如下内容:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br></pre></td></tr></table></figure><p>重启一下电脑即可生效。</p><h2 id="字体配置"><a href="#字体配置" class="headerlink" title="字体配置"></a>字体配置</h2><p>安装字体支持 <code>emoji</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S noto-fonts-emoji  <span class="comment"># Google 的 emoji 字体</span></span><br><span class="line">yay ttf-symbola  <span class="comment"># 提供许多 Unicode 符号，包括 Emoji</span></span><br></pre></td></tr></table></figure><p>中文字体:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S wqy-microhei</span><br><span class="line">sudo pacman -S wqy-zenhei</span><br><span class="line">sudo pacman -S wqy-bitmapfont </span><br></pre></td></tr></table></figure><h2 id="修改主目录为英文"><a href="#修改主目录为英文" class="headerlink" title="修改主目录为英文"></a>修改主目录为英文</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S xdg-user-dirs-gtk</span><br><span class="line"><span class="built_in">export</span> LANG=en_US</span><br><span class="line">xdg-user-dirs-gtk-update</span><br><span class="line"><span class="comment"># 然后会有个窗口提示语言更改，更新名称即可</span></span><br><span class="line"><span class="built_in">export</span> LANG=zh_CN.UTF-8</span><br><span class="line">sudo pacman -Rs xdg-user-dirs-gtk</span><br></pre></td></tr></table></figure><h1 id="软件安装"><a href="#软件安装" class="headerlink" title="软件安装"></a>软件安装</h1><h2 id="zsh"><a href="#zsh" class="headerlink" title="zsh"></a>zsh</h2><p>使用 <a href="https://github.com/ohmyzsh/ohmyzsh">oh-my-zsh</a> 来管理 <code>zsh</code> 配置。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装</span></span><br><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br><span class="line"><span class="comment"># 如果没有切换到默认 shell 可手动设置</span></span><br><span class="line">chsh -s /bin/zsh </span><br></pre></td></tr></table></figure><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>可以使用 <code>yay</code> 安装：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">yay -S jdk8  <span class="comment"># 安装 JDK8</span></span><br><span class="line"><span class="comment"># 查看 JDK</span></span><br><span class="line">archlinux-java status</span><br><span class="line"><span class="comment"># 设置默认</span></span><br><span class="line">sudo archlinux-java <span class="built_in">set</span> java-8-jdk</span><br></pre></td></tr></table></figure><h2 id="VIM"><a href="#VIM" class="headerlink" title="VIM"></a>VIM</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S vim  </span><br></pre></td></tr></table></figure><p>推荐使用 <a href="https://github.com/junegunn/vim-plug">vim plug</a> 来进行插件管理。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">    https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><h2 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S proxychains-ng</span><br><span class="line"><span class="comment"># 修改配置文件</span></span><br><span class="line">sudo vim /etc/proxychains.conf</span><br><span class="line"><span class="comment"># 添加 如下语句到最后</span></span><br><span class="line">socks5 127.0.0.1 1080 <span class="comment"># 假设端口为 1080</span></span><br></pre></td></tr></table></figure><h2 id="常见软件"><a href="#常见软件" class="headerlink" title="常见软件"></a>常见软件</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S deepin-screenshot <span class="comment"># 深度截图</span></span><br><span class="line">sudo pacman -S deepin-system-monitor <span class="comment"># 系统状态监控</span></span><br><span class="line">sudo pacman -S postman-bin <span class="comment"># HTTP</span></span><br><span class="line">sudo pacman -S visual-studio-code-bin</span><br><span class="line">sudo pacman -S unrar unzip</span><br><span class="line">sudo pacman -S net-tools</span><br><span class="line">sudo pacman -S jetbrains-toolbox</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.lkhardy.cn/categories/Linux/"/>
    
    <category term="Manjaro" scheme="https://blog.lkhardy.cn/categories/Linux/Manjaro/"/>
    
    
    <category term="Linux" scheme="https://blog.lkhardy.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Manjaro 使用中出现的奇妙问题</title>
    <link href="https://blog.lkhardy.cn/2020/03/08/linux-manjaro-questions/"/>
    <id>https://blog.lkhardy.cn/2020/03/08/linux-manjaro-questions/</id>
    <published>2020-03-08T15:36:17.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>此处记录使用 <code>Linux</code> 发行版 <code>Manjaro</code> 中出现的一些小问题，以及对应的解决方式。</p><h1 id="包管理"><a href="#包管理" class="headerlink" title="包管理"></a>包管理</h1><h2 id="切换快速源"><a href="#切换快速源" class="headerlink" title="切换快速源"></a>切换快速源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman-mirrors -i -c China -m rank</span><br></pre></td></tr></table></figure><h2 id="Pacman-更新时出现文件已存在"><a href="#Pacman-更新时出现文件已存在" class="headerlink" title="Pacman 更新时出现文件已存在"></a>Pacman 更新时出现文件已存在</h2><p>报出的错误如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">conflicting files:</span><br><span class="line">npm: /usr/lib/node_modules/npm/node_modules/minizlib/node_modules/minipass/LICENSE already exists in filesystem</span><br><span class="line">npm: /usr/lib/node_modules/npm/node_modules/minizlib/node_modules/minipass/README.md already exists in filesystem</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>解决方式</p><p>可以直接使用 <code>overwrite</code> 强制重写文件:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S npm --overwrite /path/to/npm</span><br></pre></td></tr></table></figure><h1 id="软件"><a href="#软件" class="headerlink" title="软件"></a>软件</h1><h2 id="输入法"><a href="#输入法" class="headerlink" title="输入法"></a>输入法</h2><p>搜狗输入法一直提示 <code>搜狗输入法异常，请删除 ~/.config/SogouPY</code>.</p><p>系统版本为:</p><ul><li>Manjaro: 19.0.2 Kyria</li><li>KDE 5.68.0 / Plasma 5.18.3</li></ul><p>直接在命令行输入命令 <code>sogou-qimpanel</code> 返回无法找到 <code>libfcitx-qt.so</code>。</p><p>原因是未安装包 <code>fcitx-qt4</code>。进而执行安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S fcitx-qt4</span><br></pre></td></tr></table></figure><p>提示了 <code>fcitx-lilydjwg-git</code> 与 <code>fctix</code> 出现冲突，卸载当前的 <code>fctix</code> 即可。</p><h1 id="硬件"><a href="#硬件" class="headerlink" title="硬件"></a>硬件</h1><h2 id="蓝牙"><a href="#蓝牙" class="headerlink" title="蓝牙"></a>蓝牙</h2><p>安装依赖</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pacman -S bluez bluez-utils pulseaudio-bluetooth pavucontrol pulseaudio-alsa pulseaudio-bluetooth-a2dp-gdm-fix</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;/assets/css/APlayer.min.css&quot;&gt;&lt;script src=&quot;/assets/js/APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="Linux" scheme="https://blog.lkhardy.cn/categories/Linux/"/>
    
    <category term="Manjaro" scheme="https://blog.lkhardy.cn/categories/Linux/Manjaro/"/>
    
    
    <category term="Linux" scheme="https://blog.lkhardy.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Python 数据类 dataclasses 实践</title>
    <link href="https://blog.lkhardy.cn/2019/11/23/lan-python-dataclassess/"/>
    <id>https://blog.lkhardy.cn/2019/11/23/lan-python-dataclassess/</id>
    <published>2019-11-23T13:37:40.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>从 <code>Python3.7</code> 版本开始，引入了一个新的模块 <code>dataclasses</code>，该模块主要提供了一种数据类的数据类的实现方式。基于 <a href="https://www.python.org/dev/peps/pep-0557/">PEP-557</a>实现。 所谓数据类，类似 <code>Java</code> 语言中的 <code>Bean</code>。通过一个容器类(class)，继而使用对象的属性访问数据。</p><p>如果你使用过标准库中的 <code>collections.namedtuple</code>, 或者 <code>typing.NamedTuple</code>，<code>dataclasses</code>是与这两者类似的。</p><p>通过 <code>dataclasses</code> 我们可以更加方便的去定义一个数据类。并且可以通过原生的方式进行类型检查。</p><p>一个基础例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InventoryItem</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;Class for keeping track of an item in inventory.&#x27;&#x27;&#x27;</span></span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    unit_price: <span class="built_in">float</span></span><br><span class="line">    quantity_on_hand: <span class="built_in">int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">total_cost</span>(<span class="params">self</span>) -&gt; <span class="built_in">float</span>:</span><br><span class="line">        <span class="keyword">return</span> self.unit_price * self.quantity_on_hand</span><br></pre></td></tr></table></figure><h1 id="基础用法"><a href="#基础用法" class="headerlink" title="基础用法"></a>基础用法</h1><p><code>dataclasses</code> 提供一个模块级的装饰器 <code>dataclass</code> 用来将类转化为数据类。该装饰器的原型定义如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclasses.dataclass(<span class="params">*, init=<span class="literal">True</span>, <span class="built_in">repr</span>=<span class="literal">True</span>, eq=<span class="literal">True</span>, order=<span class="literal">False</span>, unsafe_hash=<span class="literal">False</span>, frozen=<span class="literal">False</span></span>)</span></span><br></pre></td></tr></table></figure><p>提供的默认参数用来控制是否生成相应的魔术方法。如 <code>repr</code> 为 <code>True</code> 时，将会自动生成 <code>__repr__</code> 方法。</p><p>我们定义一个简单的数据类，用以实现一个使用对象的属性存储实体 <code>Person</code> 数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclasses.dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span>:</span><br><span class="line">    name: <span class="built_in">str</span></span><br><span class="line">    age: <span class="built_in">int</span> = <span class="number">20</span></span><br></pre></td></tr></table></figure><p>该类中定义了两个属性 <code>name</code> 和 <code>age</code>。分别表示名称和年龄，并且说明 <code>name</code> 属性是一个字符串，<code>age</code> 属性是一个数字(注意： 因为 <code>Python</code> 编译器不会对此处的类型进行强制检查)，并为 <code>age</code> 属性设置了默认值 <code>20</code>。</p><p>我们可以这样去使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">In [1]: person = Person(<span class="string">&#x27;ikaros&#x27;</span>, 24)</span><br><span class="line"></span><br><span class="line">In [2]: person.name</span><br><span class="line">Out[2]: <span class="string">&#x27;ikaros&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 因为默认情况下 `repr` 是自动生成的，所以我们得到 `person` 的字符串表示。</span></span><br><span class="line">In [3]: person</span><br><span class="line">Out[3]: Person(name=<span class="string">&#x27;ikaros&#x27;</span>, age=24)</span><br></pre></td></tr></table></figure><p>通过使用 <code>field</code> 我们可以对参数做更多的定制化，如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@dataclasses.dataclass</span><br><span class="line">class Person:</span><br><span class="line">    name: str</span><br><span class="line">    age: int = dataclasses.field(default=20, repr=False)</span><br></pre></td></tr></table></figure><p>此处我们为 <code>age</code> 属性赋予了一个额外的 <code>repr</code> 为 <code>False</code> 的参数。该参数说明，在调用 <code>__repr__</code> 方法时，不展示 <code>age</code> 属性：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [4]: person</span><br><span class="line">Out[4]: Person(name=<span class="string">&#x27;ikaros&#x27;</span>)</span><br></pre></td></tr></table></figure><p>更多的 <code>field</code> 说明，可以查看 <a href="https://docs.python.org/zh-cn/3.7/library/dataclasses.html#dataclasses.field">参考文档</a>。</p><h1 id="实例说明"><a href="#实例说明" class="headerlink" title="实例说明"></a>实例说明</h1><p>此处我们通过一个实际的例子展示 <code>dataclasses</code> 的用法.</p><p>现有一个数据实体内部的数据如下：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;20531316728&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;about&quot;</span><span class="punctuation">:</span> <span class="string">&quot;The Facebook Page celebrates how our friends inspire us, support us, and help us discover the world when we connect.&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;birthday&quot;</span><span class="punctuation">:</span> <span class="string">&quot;02/04/2004&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;name&quot;</span><span class="punctuation">:</span> <span class="string">&quot;Facebook&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;username&quot;</span><span class="punctuation">:</span> <span class="string">&quot;facebookapp&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;fan_count&quot;</span><span class="punctuation">:</span> <span class="number">214643503</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;cover&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">        <span class="attr">&quot;cover_id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10158913960541729&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;offset_x&quot;</span><span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;offset_y&quot;</span><span class="punctuation">:</span> <span class="number">50</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;source&quot;</span><span class="punctuation">:</span> <span class="string">&quot;https://scontent.xx.fbcdn.net/v/t1.0-9/s720x720/73087560_10158913960546729_8876113648821469184_o.jpg?_nc_cat=1&amp;_nc_ohc=bAJ1yh0abN4AQkSOGhMpytya2quC_uS0j0BF-XEVlRlgwTfzkL_F0fojQ&amp;_nc_ht=scontent.xx&amp;oh=2964a1a64b6b474e64b06bdb568684da&amp;oe=5E454425&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;id&quot;</span><span class="punctuation">:</span> <span class="string">&quot;10158913960541729&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>我们通过定义一个对应的数据类来表示该数据实体：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span>:</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">str</span> = <span class="literal">None</span></span><br><span class="line">    about: <span class="built_in">str</span> = field(default=<span class="literal">None</span>, <span class="built_in">repr</span>=<span class="literal">False</span>)</span><br><span class="line">    birthday: <span class="built_in">str</span> = field(default=<span class="literal">None</span>, <span class="built_in">repr</span>=<span class="literal">False</span>)</span><br><span class="line">    name: <span class="built_in">str</span> = <span class="literal">None</span></span><br><span class="line">    username: <span class="built_in">str</span> = <span class="literal">None</span></span><br><span class="line">    fan_count: <span class="built_in">int</span> = field(default=<span class="literal">None</span>, <span class="built_in">repr</span>=<span class="literal">False</span>)</span><br><span class="line">    cover: <span class="built_in">dict</span> = field(default=<span class="literal">None</span>, <span class="built_in">repr</span>=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><p>将数据传入到数据类中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># data 为 上述的数据</span></span><br><span class="line">In [5]: p = Page(**data)</span><br></pre></td></tr></table></figure><p>对数据进行操作：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取数据</span></span><br><span class="line">In [6]: p.name</span><br><span class="line">Out[6]: <span class="string">&#x27;Facebook&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串展示</span></span><br><span class="line">In [7]: p</span><br><span class="line">Out[8]: Page(<span class="built_in">id</span>=<span class="string">&#x27;20531316728&#x27;</span>, name=<span class="string">&#x27;Facebook&#x27;</span>, username=<span class="string">&#x27;facebookapp&#x27;</span>)</span><br><span class="line"></span><br><span class="line">In [9]: p.cover</span><br><span class="line">Out[9]: </span><br><span class="line">&#123;<span class="string">&#x27;cover_id&#x27;</span>: <span class="string">&#x27;10158913960541729&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;offset_x&#x27;</span>: 50,</span><br><span class="line"> <span class="string">&#x27;offset_y&#x27;</span>: 50,</span><br><span class="line"> <span class="string">&#x27;source&#x27;</span>: <span class="string">&#x27;https://scontent.xx.fbcdn.net/v/t1.0-9/s720x720/73087560_10158913960546729_8876113648821469184_o.jpg?_nc_cat=1&amp;_nc_ohc=bAJ1yh0abN4AQkSOGhMpytya2quC_uS0j0BF-XEVlRlgwTfzkL_F0fojQ&amp;_nc_ht=scontent.xx&amp;oh=2964a1a64b6b474e64b06bdb568684da&amp;oe=5E454425&#x27;</span>,</span><br><span class="line"> <span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;10158913960541729&#x27;</span>&#125;</span><br></pre></td></tr></table></figure><p>上述完整代码参见 <a href="https://github.com/MerleLiuKun/my-python/blob/master/sundries/dataclass/demo1.py">demo1</a> </p><p>我们在上述的代码发现, 在调用 <code>p.cover</code> 属性时，返回的是一个字典，在正常的使用时，我们是想将 <code>cover</code> 属性也声明为一个数据类。则需要对上述的代码进行修改。</p><p>添加一个 <code>Cover</code> 的数据类实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cover</span>:</span><br><span class="line">    <span class="built_in">id</span>: <span class="built_in">str</span> = <span class="literal">None</span></span><br><span class="line">    cover_id: <span class="built_in">str</span> = <span class="literal">None</span></span><br><span class="line">    offset_x: <span class="built_in">str</span> = field(default=<span class="literal">None</span>, <span class="built_in">repr</span>=<span class="literal">False</span>)</span><br><span class="line">    offset_y: <span class="built_in">str</span> = field(default=<span class="literal">None</span>, <span class="built_in">repr</span>=<span class="literal">False</span>)</span><br><span class="line">    source: <span class="built_in">str</span> = field(default=<span class="literal">None</span>, <span class="built_in">repr</span>=<span class="literal">False</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span>:</span><br><span class="line">    ...  <span class="comment"># 此处不再复制上方的属性</span></span><br><span class="line">    cover: Cover = field(default=<span class="literal">None</span>, <span class="built_in">repr</span>=<span class="literal">False</span>)  <span class="comment"># 修改 `cover` 属性</span></span><br></pre></td></tr></table></figure><p>但是这时候，如果我们按照刚才的初始化方式，<code>cover</code> 属性不会被识别到。</p><p>我们可以通过添加一个额外的初始化的方法用来初始化到 <code>cover</code> 属性.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">dicts_to_dataclasses</span>(<span class="params">instance</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;将所有的数据类属性都转化到数据类中&quot;&quot;&quot;</span></span><br><span class="line">    cls = <span class="built_in">type</span>(instance)</span><br><span class="line">    <span class="keyword">for</span> f <span class="keyword">in</span> fields(cls):</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> is_dataclass(f.<span class="built_in">type</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        value = <span class="built_in">getattr</span>(instance, f.name)</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">dict</span>):</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">        new_value = f.<span class="built_in">type</span>(**value)</span><br><span class="line">        <span class="built_in">setattr</span>(instance, f.name, new_value)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>并且修改上层数据类 <code>Page</code> 的代码，添加一个 <code>__post_init__</code> 方法， 该方法会被自动生成的 <code>__init__</code> 方法调用，进而将 <code>Cover</code> 数据类进行初始化。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@dataclass</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Page</span>:</span><br><span class="line">    ...  <span class="comment"># 上方的属性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__post_init__</span>(<span class="params">self</span>):</span><br><span class="line">        dicts_to_dataclasses(self)</span><br></pre></td></tr></table></figure><p>上述完整代码参见 <a href="https://github.com/MerleLiuKun/my-python/blob/master/sundries/dataclass/demo2.py">demo2</a></p><p>此时我们去初始化时，便可以将子数据类 <code>Cover</code> 也初始化了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">In [10]: p.cover</span><br><span class="line">Out[10]: Cover(<span class="built_in">id</span>=<span class="string">&#x27;10158913960541729&#x27;</span>, cover_id=<span class="string">&#x27;10158913960541729&#x27;</span>)</span><br></pre></td></tr></table></figure><p>此外，<code>dataclasses</code> 还提供了对数据类到字典的转化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">In [11]: from dataclasses import asdict</span><br><span class="line">In [12]: asdict(p)</span><br><span class="line">Out[12]:</span><br><span class="line">&#123;<span class="string">&#x27;id&#x27;</span>: <span class="string">&#x27;20531316728&#x27;</span>,</span><br><span class="line">....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以对上边的代码进行整合一下。将通用的一些函数放到一个 <code>base</code> 基类中。</p><p>完整代码参见 <a href="https://github.com/MerleLiuKun/my-python/blob/master/sundries/dataclass/demo3.py">demo3</a></p><h1 id="第三方增强库"><a href="#第三方增强库" class="headerlink" title="第三方增强库"></a>第三方增强库</h1><p>上边我们只是对含有嵌套字典的复杂数据进行了处理。事实上，生产中的数据的样式会更加复杂。我们根据需求自行对 <code>dicts_to_dataclasses</code> 函数进行升级处理，或者使用第三方库进行处理。</p><p>此处我们以第三方库 <code>dataclasses-json</code> 来给出一个示例，详细代码参见 <a href="https://github.com/MerleLiuKun/my-python/blob/master/sundries/dataclass/demo_with_dataclasses_json.py">demo-with-dataclasses-json</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://www.kawabangga.com/posts/2959">Python3.7 dataclass 介绍</a></li><li><a href="https://docs.python.org/zh-cn/3.7/library/dataclasses.html">dataclasses—数据类(官方文档)</a></li><li><a href="https://github.com/lidatong/dataclasses-json">dataclasses-json</a></li></ul>]]></content>
    
    
    <summary type="html">Python 数据类 dataclasses 实践</summary>
    
    
    
    <category term="Python" scheme="https://blog.lkhardy.cn/categories/Python/"/>
    
    
    <category term="python" scheme="https://blog.lkhardy.cn/tags/python/"/>
    
    <category term="dataclasses" scheme="https://blog.lkhardy.cn/tags/dataclasses/"/>
    
  </entry>
  
  <entry>
    <title>优化你的git-commit-message</title>
    <link href="https://blog.lkhardy.cn/2019/08/20/tool-git-message/"/>
    <id>https://blog.lkhardy.cn/2019/08/20/tool-git-message/</id>
    <published>2019-08-20T11:59:03.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>无论是写公司的项目或者是自己的项目时，总要向仓库中提交代码。每个人提交代码时写的提交信息都不一样。有随意写各种 <code>modify</code>, <code>fix</code>等简单的，还有一些比较友好，会写上自己此次提交的简介。个人觉得第二种对代码review，或者查找bug引入点时会更有帮助。</p><p>简单做个比较如下：</p><p>一、</p><p><img src="https://i.loli.net/2020/03/04/MqJTHIiYvfgP8dL.png" alt="formated.png"></p><p>二、<br><img src="https://i.loli.net/2020/03/04/Xvye7MmskE2QrC5.png" alt="not_formated.png"></p><p>对比之下第一种更加清晰明了。</p><h1 id="规范-Commit-message"><a href="#规范-Commit-message" class="headerlink" title="规范 Commit message"></a>规范 Commit message</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>基本上很多团队都有自己的相关规范说明，但是目前使用的比较广泛是 <a href="https://docs.google.com/document/d/1QrDFcIiPjSLDn3EL15IJygNPiHORgU1_OOAqWjiDU5Y/edit#heading=h.greljkmo14y0">Angular 规范</a>, 基本样式如 上文第一张图所示。</p><p>使用依据规范的 <code>Commit message</code> 会有很多好处， 比如：</p><p>(1) 提供更多的信息，方便快速浏览。</p><p>基于规范的 <code>message</code> 可以直接信息中就包含此次提交的内容。也可以基于 <code>message</code>进行过滤</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span> v0.3 HEAD --grep feat</span><br></pre></td></tr></table></figure><p>(2) 可以直接根据 <code>commit</code> 生成对应的 <code>Change Log</code>.</p><h2 id="Commit-message-格式"><a href="#Commit-message-格式" class="headerlink" title="Commit message 格式"></a>Commit message 格式</h2><p>每次提交 都需要包含三部分：Header，Body 和 Footer。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;</span><br><span class="line"><span class="comment">// 空一行</span></span><br><span class="line">&lt;body&gt;</span><br><span class="line"><span class="comment">// 空一行</span></span><br><span class="line">&lt;footer&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>header</code>  是必须的，另外两个可以不写。</p><ul><li>标题行: 必填, 描述主要修改类型和内容</li><li>主题内容: 描述为什么修改, 做了什么样的修改, 以及开发的思路等等</li><li>页脚注释: 放 Breaking Changes 或 Closed Issues</li></ul><p>其中 标题包括三个字段：<code>type</code>（必需）、<code>scope</code>（可选）和 <code>subject</code>（必需）。</p><p>type 有以下一些常见类型：</p><ul><li>feat：新功能（feature）</li><li>fix：修补bug</li><li>docs：文档（documentation）</li><li>style： 格式（不影响代码运行的变动）</li><li>refactor：重构（即不是新增功能，也不是修改bug的代码变动）</li><li>test：增加测试</li><li>chore：构建过程或辅助工具的变动</li></ul><p>scope 说明此次变动的范围，一般视具体的项目而定。</p><p>subject 是此次提交的简要描述。</p><h1 id="工具-Commitizen"><a href="#工具-Commitizen" class="headerlink" title="工具 Commitizen"></a>工具 Commitizen</h1><p>如果我们每次手写以上的格式，必定是个痛苦的事情。所以可以使用 <a href="https://github.com/commitizen/cz-cli">Commitizen</a><br>这个格式化工具进行撰写.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>可以进行全局安装或者基于某项目安装。</p><p>全局安装如下：</p><p>需要在配置文件中指定 <code>Adapter</code></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install -g commitizen cz-conventional-changelog</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;&#123; &quot;path&quot;: &quot;cz-conventional-changelog&quot; &#125;&#x27;</span> &gt; ~/.czrc</span><br></pre></td></tr></table></figure><p>当然可能你喜欢的格式与某个项目下要求的格式不一致。可以在某项目下进行配置。</p><p>项目内安装：<br>需要在项目目录下配置 <code>package.json</code>文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">npm install -D commitizen cz-conventional-changelog</span><br><span class="line"></span><br><span class="line"># 以下写入package.json.</span><br><span class="line">&quot;script&quot;: &#123;</span><br><span class="line">    ...,</span><br><span class="line">    &quot;commit&quot;: &quot;git-cz&quot;,</span><br><span class="line">&#125;,</span><br><span class="line"> &quot;config&quot;: &#123;</span><br><span class="line">    &quot;commitizen&quot;: &#123;</span><br><span class="line">      &quot;path&quot;: &quot;node_modules/cz-conventional-changelog&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>需要提交代码时，执行 <code>git cz -a</code></p><p>效果如下：</p><p><img src="https://i.loli.net/2020/03/04/Gd3nLRyQW4XoOSl.png" alt="commitizen.png"></p><h2 id="自定义"><a href="#自定义" class="headerlink" title="自定义"></a>自定义</h2><p>如果需要自行配置相关的 <code>Adapter</code>, 可以使用 <a href="https://github.com/leonardoanalista/cz-customizable">cz-customizable</a> 进行自定义。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm i -g cz-customizable  <span class="comment"># 全局</span></span><br><span class="line">npm i -D cz-customizable  <span class="comment"># 项目级</span></span><br></pre></td></tr></table></figure><p>修改对应的配置：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局 .czrc</span></span><br><span class="line">&#123; <span class="string">&quot;path&quot;</span>: <span class="string">&quot;cz-customizable&quot;</span> &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 项目级 (package.json)</span></span><br><span class="line"><span class="string">&quot;config&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;commitizen&quot;</span>: &#123;</span><br><span class="line">        <span class="string">&quot;path&quot;</span>: <span class="string">&quot;node_modules/cz-customizable&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>推荐一下大佬的配置 <a href="https://gist.github.com/leohxj/7bc928f60bfa46a3856ddf7c0f91ab98"> leohxj/.cz-config.js</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html">Commit message 和 Change log 编写指南-阮一峰</a></li><li><a href="https://zhuanlan.zhihu.com/p/34223150">优雅的提交你的 Git Commit Message-阿里南京技术专刊</a></li></ul>]]></content>
    
    
    <summary type="html">优化你的git-commit-message</summary>
    
    
    
    <category term="Git" scheme="https://blog.lkhardy.cn/categories/Git/"/>
    
    
    <category term="git" scheme="https://blog.lkhardy.cn/tags/git/"/>
    
    <category term="commitizen" scheme="https://blog.lkhardy.cn/tags/commitizen/"/>
    
  </entry>
  
  <entry>
    <title>Git submodule 子模块管理</title>
    <link href="https://blog.lkhardy.cn/2019/08/01/tool-git-submodule/"/>
    <id>https://blog.lkhardy.cn/2019/08/01/tool-git-submodule/</id>
    <published>2019-08-01T13:59:04.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在使用某些大型项目时，会发现项目会引用了其他的一些项目，而引用的这些项目也会进行一些更新维护的操作。那么如何对这些子项目进行管理呢？ 当然你可以将子项目的更新进行手动调整，进而提交到主项目中。但是这种操作并不友好，并且会污染主项目的提交历史。</p><p><code>Git</code> 通过子模块 <a href="https://github.blog/2016-02-01-working-with-submodules/">submodule</a> 来解决这样的问题。子模块允许你将一个 <code>Git</code> 仓库作为另一个 <code>Git</code> 仓库的子目录。 它能让你将另一个仓库克隆到自己的项目中，同时还保持提交的独立。</p><p>在使用 <code>Hexo</code> 搭建静态博客时，我们会通常不会选用内置的主题，而是选择更好看的第三方主题。那么就是上边我们说的场景。我们要在博客的主仓库中对主题的仓库进行统一处理。我们以此为例，简单介绍一下对子模块的使用。</p><h1 id="开始使用子模块"><a href="#开始使用子模块" class="headerlink" title="开始使用子模块"></a>开始使用子模块</h1><p>假如我们使用第三方主题 <a href="https://github.com/iissnan/hexo-theme-next">hexo-theme-next</a>。通过命令 <code>git submodule add</code> 来添加新的子模块。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/iissnan/hexo-theme-next</span><br></pre></td></tr></table></figure><p>此时会把主题项目 <code>hexo-theme-next</code> 克隆到当前目录下的同名目录中。如果你想要将其放置到其他目录，可以在命令后边加上制定的目录，例如：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git submodule add https://github.com/iissnan/hexo-theme-next themes/hexo-theme-next</span><br></pre></td></tr></table></figure><p>此时你可以使用 <code>git status</code> 命令查看当前仓库的状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is up-to-date with <span class="string">&#x27;origin/master&#x27;</span>.</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line">        新文件：   .gitmodules</span><br><span class="line">        新文件：   themes/hexo-theme-next</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>关键注意点是文件 <code>.gitmodules</code>，该配置文件存储了项目和本地目录之间的映射关系。<br>其中 <code>path</code> 指定本地的相对目录，<code>url</code> 指定子项目的仓库地址。</p><p>该文件需要进行版本控制，用于其他人也可以知道子模块的位置。</p><h1 id="克隆含有子模块的项目"><a href="#克隆含有子模块的项目" class="headerlink" title="克隆含有子模块的项目"></a>克隆含有子模块的项目</h1><p>如果需要完整克隆带有子模块的项目，有两种方式：</p><ol><li>正常克隆主项目，然后更新子模块</li><li>使用参数 <code>--recursive</code> 自动初始化并更新所有的子模块</li></ol><h2 id="先克隆后更新"><a href="#先克隆后更新" class="headerlink" title="先克隆后更新"></a>先克隆后更新</h2><p>先克隆主项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git@github.com:MerleLiuKun/merleliukun.github.io.git</span><br></pre></td></tr></table></figure><p>切换到项目目录下，初始化子模块，注意初始化只需要执行一次</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule init</span><br></pre></td></tr></table></figure><p>更新子模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule update</span><br></pre></td></tr></table></figure><h2 id="递归克隆整个项目"><a href="#递归克隆整个项目" class="headerlink" title="递归克隆整个项目"></a>递归克隆整个项目</h2><p>采用递归参数 <code>--recursive</code>  克隆项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> --recursive git@github.com:MerleLiuKun/merleliukun.github.io.git</span><br></pre></td></tr></table></figure><h1 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h1><h2 id="查看子模块"><a href="#查看子模块" class="headerlink" title="查看子模块"></a>查看子模块</h2><p>切换到主项目目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule </span><br><span class="line">620b1e829eb8b6fd72426f3009866b79d8ee2e7b themes/hexo-theme-next (v5.1.1-693-g620b1e8)</span><br></pre></td></tr></table></figure><h2 id="删除子模块"><a href="#删除子模块" class="headerlink" title="删除子模块"></a>删除子模块</h2><p>切换到主项目目录下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git submodule deinit themes/hexo-theme-next</span><br><span class="line">$ git <span class="built_in">rm</span> themes/hexo-theme-next</span><br></pre></td></tr></table></figure><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><ul><li><a href="https://git-scm.com/book/en/v2/Git-Tools-Submodules">Git-Tools-Submodules</a></li><li><a href="https://github.blog/2016-02-01-working-with-submodules/">Working with submodules</a></li></ul>]]></content>
    
    
    <summary type="html">Git submodule 子模块管理</summary>
    
    
    
    <category term="Git" scheme="https://blog.lkhardy.cn/categories/Git/"/>
    
    
    <category term="git" scheme="https://blog.lkhardy.cn/tags/git/"/>
    
    <category term="submodule" scheme="https://blog.lkhardy.cn/tags/submodule/"/>
    
  </entry>
  
  <entry>
    <title>MinIO对象存储服务介绍</title>
    <link href="https://blog.lkhardy.cn/2019/05/25/tool-minio-tutorial/"/>
    <id>https://blog.lkhardy.cn/2019/05/25/tool-minio-tutorial/</id>
    <published>2019-05-25T09:40:16.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p><a href="https://docs.min.io/cn/minio-quickstart-guide.html">MinIO</a> 是一个基于 <code>Apache License v2.0</code> 开源协议的对象存储服务。它兼容亚马逊S3云存储服务接口，非常适合于存储大容量非结构化的数据，例如图片、视频、日志文件、备份数据和容器/虚拟机镜像等，而一个对象文件可以是任意大小，从几kb到最大5T不等。</p><p><code>MinIO</code> 是一个非常轻量的服务,可以很简单的和其他应用的结合，类似 NodeJS, Redis 或者 MySQL.</p><p>简单来说, 我们可以基于 <code>MinIO</code> 搭建一个类似亚马逊S3(腾讯云OSS)的存储服务。</p><h1 id="安装部署"><a href="#安装部署" class="headerlink" title="安装部署"></a>安装部署</h1><p>官网上给出的安装步骤十分详细和完整。这里只简单罗列一下。 以下使用 <code>Docker</code> 进行部署的.</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p><a href="https://docs.min.io/cn/minio-quickstart-guide.html">官网详细安装说明</a></p><p>拉取镜像</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull minio/minio</span><br></pre></td></tr></table></figure><p>为了方便升级，迁移等操作, 我们将 <code>MinIO</code> 的数据放到宿主机上, 然后挂载到容器里。另外因为使用 <code>Docker</code> 部署, 所以需要自定义初始的账号信息. 基础的命令如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sudo docker run -p 9000:9000 --name minio-server \</span><br><span class="line">  -e <span class="string">&quot;MINIO_ACCESS_KEY=Your Key&quot;</span> \</span><br><span class="line">  -e <span class="string">&quot;MINIO_SECRET_KEY=Your Secret&quot;</span> \</span><br><span class="line">  -v /data/minio_data:/data \</span><br><span class="line">  -v /data/minio_config:/root/.minio \</span><br><span class="line">  -d minio/minio server /data</span><br></pre></td></tr></table></figure><blockquote><p>可以将命令写到脚本里, 方便修改和执行。</p></blockquote><p>此时, <code>MinIO</code> 服务已经起来了. 如果你是在本地搭建的, 可以使用你指定的账号信息访问 <a href="http://127.0.0.1:9000/">http://127.0.0.1:9000</a>. 如果可以访问, 即表明已经部署成功。</p><h2 id="Nginx配置"><a href="#Nginx配置" class="headerlink" title="Nginx配置"></a>Nginx配置</h2><p>如果我们想要搭建一个私有的存储服务，那么部署一定是在服务器上。我们可以使用 <code>Nginx</code> 配置一下代理.<br>官方也给了使用 <code>Nginx</code> 做代理的配置说明 <a href="https://docs.min.io/cn/setup-nginx-proxy-with-minio.html">为MinIO Server设置Nginx代理</a> 。</p><p>简单列一下我的配置.</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">upstream</span> minioServer &#123;</span><br><span class="line">    <span class="attribute">server</span> <span class="number">127.0.0.1:9000</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># minio</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">80</span>;</span><br><span class="line">    <span class="attribute">server_name</span>  img.example.com;  <span class="comment"># your domain</span></span><br><span class="line">    <span class="attribute">return</span> <span class="number">301</span> https://<span class="variable">$host</span><span class="variable">$request_uri</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># https</span></span><br><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>        <span class="number">443</span>;</span><br><span class="line">    <span class="attribute">server_name</span>   img.example.com;</span><br><span class="line"></span><br><span class="line">    <span class="attribute">ssl_certificate</span>      /path/to/chain.pem;</span><br><span class="line">    <span class="attribute">ssl_certificate_key</span>  /path/to/privkey.pem;</span><br><span class="line"></span><br><span class="line">    <span class="section">location</span> / &#123;</span><br><span class="line">        <span class="attribute">proxy_set_header</span> Host <span class="variable">$http_host</span>;  <span class="comment"># 请求头转发</span></span><br><span class="line">        <span class="attribute">proxy_pass</span> http://minioServer;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启 <code>Nginx</code> 服务. 然后可以 访问 <a href="https://img.example.com/">https://img.example.com</a> 来验证配置状态。</p><h2 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h2><p><code>MinIO</code> 提供了更多的一些配置，比如 <code>TLS安全访问</code>, <code>状态通知</code>等, 可以依据官方文档进行相关的配置。</p><p>接下来, 就可以愉快的使用它了。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://github.com/minio/minio">官方Github</a></li><li><a href="https://docs.min.io/">官方文档</a></li></ul>]]></content>
    
    
    <summary type="html">MinIO对象存储服务介绍</summary>
    
    
    
    <category term="storage" scheme="https://blog.lkhardy.cn/categories/storage/"/>
    
    <category term="minio" scheme="https://blog.lkhardy.cn/categories/storage/minio/"/>
    
    
    <category term="storage" scheme="https://blog.lkhardy.cn/tags/storage/"/>
    
    <category term="minio" scheme="https://blog.lkhardy.cn/tags/minio/"/>
    
  </entry>
  
  <entry>
    <title>MySQL查询优化一</title>
    <link href="https://blog.lkhardy.cn/2019/05/14/sql-mysql-query-optimize-1/"/>
    <id>https://blog.lkhardy.cn/2019/05/14/sql-mysql-query-optimize-1/</id>
    <published>2019-05-14T11:38:02.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>多数情况下，我们知道索引能够提高查询效率，但应该如何建立索引？索引的顺序如何？许多人却只知道大概。其实理解这些概念并不难，而且索引的原理远没有想象的那么复杂。</p><h1 id="建立索引的几大原则"><a href="#建立索引的几大原则" class="headerlink" title="建立索引的几大原则"></a>建立索引的几大原则</h1><h2 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h2><p>简单定义:<br>MySQL会一直向右匹配直到遇到范围查询 <code>(&gt;,&lt;,between,like)</code> 就停止匹配.</p><p>所以在针对查询条件进行创建索引时，要将范围级的条件放到索引字段的最后。以让 <code>MySQL</code> 使用索引。</p><h2 id="查询优化器"><a href="#查询优化器" class="headerlink" title="查询优化器"></a>查询优化器</h2><p>理论上来说 索引对顺序很敏感，但是MySQL的查询优化器会自动调整where子句的条件顺序以使用适合的索引。这属于编译器层次优化.<br>举例： 当 <code>where</code> 条件为 <code>a=1 AND b=2 AND c=3</code> 时, 对应建立的索引 <code>(a,b,c)</code> 列可以以任意顺序建立</p><h2 id="选择区分度高的列"><a href="#选择区分度高的列" class="headerlink" title="选择区分度高的列"></a>选择区分度高的列</h2><p>如果列的区分度很小，那么为这个列创建索引就不太合适了。比如 性别、某些状态字段之类的。</p><p>有个计算公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count(distinct col) / count(*)</span><br></pre></td></tr></table></figure><p>一般要求 <code>0.1</code> 以上 <a href="https://tech.meituan.com/2014/06/30/mysql-index.html">参考此处</a></p><h2 id="索引列不参与计算"><a href="#索引列不参与计算" class="headerlink" title="索引列不参与计算"></a>索引列不参与计算</h2><p>当为某列数据加上索引之后, 不能将该列直接参与计算。因为索引源数据中存的都是字段值, 使用计算时需要将所有的字段进行计算之后才能比较。 这样的情况 可以先对条件进行计算，比较计算后的值。</p><h2 id="尽量扩展索引"><a href="#尽量扩展索引" class="headerlink" title="尽量扩展索引"></a>尽量扩展索引</h2><p>当表中已经存在索引，需要新增索引列时，优先考虑在原有的索引上进行增加。<br>如: 已存在索引 <code>(a)</code>, 需要增加联合索引 <code>(a,b)</code> 时， 可以直接在原索引上修改。</p><p>但如果需要添加的另外的与当前索引列无关的索引时，需要另外创建。</p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://tech.meituan.com/2014/06/30/mysql-index.html">MySQL索引原理及慢查询优化</a></li><li><a href="https://book.douban.com/subject/24708143/">MySQL技术内幕:InnoDB存储引擎(第2版)</a></li><li><a href="https://www.cnblogs.com/nixi8/p/4574709.html">MySQL索引攻略</a></li></ul>]]></content>
    
    
    <summary type="html">MySQL查询优化一</summary>
    
    
    
    <category term="sql" scheme="https://blog.lkhardy.cn/categories/sql/"/>
    
    <category term="mysql" scheme="https://blog.lkhardy.cn/categories/sql/mysql/"/>
    
    
    <category term="mysql" scheme="https://blog.lkhardy.cn/tags/mysql/"/>
    
  </entry>
  
  <entry>
    <title>令牌桶算法浅析</title>
    <link href="https://blog.lkhardy.cn/2019/04/09/alg-token-bucket/"/>
    <id>https://blog.lkhardy.cn/2019/04/09/alg-token-bucket/</id>
    <published>2019-04-09T09:01:40.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>负责的项目中有一个爬虫调度项目。基础的模型就是利用平台提供的 <code>Token</code> 通过相关的数据 <code>API</code> 从平台获取数据。<br>对于每个 <code>Token</code> 均存在一个短时间内调用的上限。一旦超出限制，将在一段时间内不能进行继续获取。<br>之前对于这个限制的管理比较简单，当任务触发时，会直接发起数据获取请求。通过检查返回信息，判断是否超限，如果超限，设置一个等待时间之后进行重试。但发现这样没有最大化的利用到 <code>Token</code>. 因为发起请求本身就是对 <code>Token</code> 的一种消耗。<br>最近跟组长进行讨论相关细节时，他提到可以利用 <code>Nginx</code> 的流量限制来进行改进。研究之后发现<code>令牌桶算法</code>很合适这个需求。</p><h2 id="令牌桶算法"><a href="#令牌桶算法" class="headerlink" title="令牌桶算法"></a>令牌桶算法</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>令牌桶(<code>token bucket</code>)算法是 <code>nginx</code> 进行流量限制的一种常用算法。常用于控制发送到网络上的数据的数量，并允许突发数据的发送。</p><h4 id="基础流程图"><a href="#基础流程图" class="headerlink" title="基础流程图"></a>基础流程图</h4><p>当数据请求来临时，算法通过检查当前桶的令牌量，如果令牌量足以支持消耗，即会进行接下来的处理。<br>如果令牌不足，则会将请求抛弃(获取缓存，看相关需求)</p><p><img src="https://i.loli.net/2020/03/04/Z9O8tBPWe2cmgzK.png" alt="token-bucket.png"></p><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>在当前的需求中，对每一个 <code>Token</code> 实例添加一个容量桶。存储当前的可调用次数。当有 <code>worker</code> 发起请求时，先检查当前的可调用余量。<br>如果余量足够，则返回可调用状态，并设置当前的处理时间。当请求完毕时，对桶进行主动更新。如果当前余量不足以进行请求，则可以返回需要等待的时间，或者执行切换 <code>Token</code> 实例等操作。</p><h4 id="简单实现"><a href="#简单实现" class="headerlink" title="简单实现"></a>简单实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TokenBucket</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, rate=<span class="number">0.1</span>, capacity=<span class="number">100</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        此 为 单例</span></span><br><span class="line"><span class="string">        初始化时 应设置 当前的容量为 总容量</span></span><br><span class="line"><span class="string">        :param rate: 速率 秒为单位</span></span><br><span class="line"><span class="string">        :param capacity: 总容量</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self._rate = rate</span><br><span class="line">        self._capacity = capacity</span><br><span class="line">        self.current_amount = capacity</span><br><span class="line">        self._last_consumed_at = <span class="built_in">int</span>(time.time())</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">consume</span>(<span class="params">self, need_amount=<span class="number">1</span></span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        进行消费</span></span><br><span class="line"><span class="string">        :param need_amount:</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        increments = (<span class="built_in">int</span>(time.time()) - self._last_consumed_at) * self._rate</span><br><span class="line">        self.current_amount = <span class="built_in">min</span>(</span><br><span class="line">            self.current_amount + increments, self._capacity</span><br><span class="line">        )</span><br><span class="line">        <span class="keyword">if</span> need_amount &gt; self.current_amount:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        self.current_amount = self.current_amount - need_amount</span><br><span class="line">        self._last_consumed_at = <span class="built_in">int</span>(time.time())</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">self, amount</span>):</span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        存在一个更新操作，用于 Token 余量状态主动返回</span></span><br><span class="line"><span class="string">        并重新计算 最后消费时间</span></span><br><span class="line"><span class="string">        :param amount: 主动发送的数量</span></span><br><span class="line"><span class="string">        :return:</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.current_amount = <span class="built_in">min</span>(amount, self._capacity)</span><br><span class="line">        self._last_consumed_at = <span class="built_in">int</span>(time.time())</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>源码可访问 <a href="https://github.com/MerleLiuKun/my-python/blob/master/crawler/distributor/token_bucket.py">code</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Token_bucket">token bucket</a></li><li><a href="https://baike.baidu.com/item/%E4%BB%A4%E7%89%8C%E6%A1%B6%E7%AE%97%E6%B3%95">令牌桶算法</a></li><li><a href="https://juejin.im/post/5ab10045518825557005db65">令牌桶实现</a></li></ul>]]></content>
    
    
    <summary type="html">令牌桶算法浅析</summary>
    
    
    
    <category term="algorithm" scheme="https://blog.lkhardy.cn/categories/algorithm/"/>
    
    <category term="nginx" scheme="https://blog.lkhardy.cn/categories/algorithm/nginx/"/>
    
    
    <category term="algorithm" scheme="https://blog.lkhardy.cn/tags/algorithm/"/>
    
    <category term="nginx" scheme="https://blog.lkhardy.cn/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title>常见的排序算法一</title>
    <link href="https://blog.lkhardy.cn/2017/08/15/alg-sort-common/"/>
    <id>https://blog.lkhardy.cn/2017/08/15/alg-sort-common/</id>
    <published>2017-08-15T08:09:30.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>按照相关排序算法的解释，手动用Python实现了一遍，记录一下。<br>排序结果为从小到大。</p><p>安利一个学习算法的经典网站：<a href="https://visualgo.net/">算法图示</a></p><p>这个网站上有很多算法的动图示例，还带有操作步骤解释，实在是居家旅行学习必备之网站。</p><h1 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>冒泡排序的原理是将临近的数字两两进行比较，然后按照从小到大或者从大到小的顺序进行交换。</p><p>动图如下：</p><p><img src="http://i.imgur.com/ydsjKFN.gif" alt="冒泡排序"></p><p>步骤</p><p>主要步骤如下：</p><ol><li>比较相邻的前后二个数据，如果前面数据大于后面的数据，就将二个数据交换。</li><li>按照1的方法对源数组的第0个数据到N-1个数据进行一次遍历后，最大的一个数据就“升”到数组第N-1个位置（就是最后一个位置）。</li><li>设置N=N-1，如果N不为0就重复前面二步，如果N==0，那么就是将原数组所有的数都排序一遍，此时排序完成。</li></ol><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort</span>(<span class="params">array</span>):</span><br><span class="line">   length = <span class="built_in">len</span>(array)</span><br><span class="line">   <span class="keyword">while</span> length &gt; <span class="number">0</span>:</span><br><span class="line">       <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span>):</span><br><span class="line">           <span class="keyword">if</span> array[i] &gt; array[i + <span class="number">1</span>]:</span><br><span class="line">               array[i], array[i + <span class="number">1</span>] = array[i + <span class="number">1</span>], array[i]</span><br><span class="line">       length -= <span class="number">1</span></span><br><span class="line">   <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><h2 id="基本优化"><a href="#基本优化" class="headerlink" title="基本优化"></a>基本优化</h2><p>1.对于结束的条件，如果遍历某一趟时，没有发生任何交换，说明此时排序已经完成，所以我们可以在程序中加上一个标志量用来表示某趟是否发生交换。</p><h2 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_better</span>(<span class="params">array</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(array)</span><br><span class="line">    flag = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">while</span> length &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> array[i] &gt; array[i + <span class="number">1</span>]:</span><br><span class="line">                array[i], array[i + <span class="number">1</span>] = array[i + <span class="number">1</span>], array[i]</span><br><span class="line">                flag = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                flag = <span class="literal">False</span></span><br><span class="line">        <span class="keyword">if</span> flag <span class="keyword">is</span> <span class="literal">False</span>:</span><br><span class="line">            <span class="keyword">return</span> array</span><br><span class="line">        length -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><p>2.如果存在这样的数组： 假设数组有100个数，但是只有前10个是无序的，后面90个是已经排序完毕，且均大于前面10个数。这样我们分析即可发现，第一趟遍历的时候，最后发生交换的位置必定小于10。所以我们只需要记录下这个最后的位置，下一次，只需要从头遍历到这个位置即可。</p><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">bubble_sort_best</span>(<span class="params">array</span>):</span><br><span class="line">    length = <span class="built_in">len</span>(array)</span><br><span class="line">    <span class="keyword">while</span> length &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(length - <span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> array[i] &gt; array[i + <span class="number">1</span>]:</span><br><span class="line">                array[i], array[i + <span class="number">1</span>] = array[i + <span class="number">1</span>], array[i]</span><br><span class="line">                length = i + <span class="number">1</span></span><br><span class="line">        length -= <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><h1 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h1><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>插入排序的基本思想就是：每次将一个待排序的记录，按其关键字大小插入到前面已经排好序的子序列中的适当位置，直到全部记录插入完成为止。</p><p>动图效果如下：<br><img src="http://i.imgur.com/6xxjaz8.gif"></p><p>步骤</p><p>设数组为a[0…n-1]。</p><ol><li>从第一个元素开始，该元素可以认为已经被排序</li><li>取出下一个元素，在已经排序的元素序列中从后向前扫描</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置</li><li>将新元素插入到该位置中</li><li>重复步骤2</li></ol><h2 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">insert_while</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(nums)):</span><br><span class="line">        deal_num = nums[index]</span><br><span class="line">        j = index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> j &gt;= <span class="number">0</span> <span class="keyword">and</span> nums[j] &gt; deal_num:</span><br><span class="line">            nums[j + <span class="number">1</span>] = nums[j]</span><br><span class="line">            j -= <span class="number">1</span></span><br><span class="line">        nums[j + <span class="number">1</span>] = deal_num</span><br></pre></td></tr></table></figure><hr><h1 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h1><h2 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h2><p>希尔排序，也称递减增量排序算法，实质是分组插入排序。由 Donald Shell 于1959年提出。希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时， 效率高， 即可以达到线性排序的效率</li><li>但插入排序一般来说是低效的， 因为插入排序每次只能将数据移动一位</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/d/d8/Sorting_shellsort_anim.gif"></p><p>步骤</p><p>我们以一组数<code>[49, 38, 65, 97, 26, 13, 27, 49, 55, 4]</code>为例。</p><p>加入首先我们以步长5排序</p><blockquote><p>49 38 65 97 26<br>13 27 49 55 4</p></blockquote><p>然后我们对每列进行排序。</p><blockquote><p>13 27 49 55 4<br>49 38 65 97 26</p></blockquote><p>合并变成了<code>[13, 27, 49, 55, 4, 49, 38, 65, 97, 26]</code>。第一轮结束。</p><p>更换步长为<code>5//2=2</code>,继续排序</p><blockquote><p>13 27<br>49 55<br>4  49<br>38 65<br>97 26  </p></blockquote><p>排序过后</p><blockquote><p>4  26<br>13 27<br>38 49<br>49 55<br>97 65</p></blockquote><p>合并：[4,26,13,27,38,49,49,55,97,65]</p><p>更换步长为<code>2//1=1</code><br>排序之后就得到了结果。</p><h2 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">shell_sort</span>(<span class="params">array, n</span>):</span><br><span class="line">    step = <span class="number">2</span></span><br><span class="line">    now_gap = n // step  <span class="comment"># 初始步长</span></span><br><span class="line">    <span class="keyword">while</span> now_gap &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(now_gap, n):</span><br><span class="line"> <span class="comment"># 每个步长进行插入排序</span></span><br><span class="line">            temp = array[i]</span><br><span class="line">            j = i</span><br><span class="line"><span class="comment"># 插入排序</span></span><br><span class="line">            <span class="keyword">while</span> j &gt;= now_gap <span class="keyword">and</span> array[j - now_gap] &gt; temp:</span><br><span class="line">                array[j] = array[j - now_gap]</span><br><span class="line">                j = j - now_gap</span><br><span class="line">            array[j] = temp</span><br><span class="line"><span class="comment"># 新的步长</span></span><br><span class="line">        now_gap //= step</span><br><span class="line">    <span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><p>基本优化</p><p>优化部分主要在与步长的选择上，请移步<a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%![](http://i.imgur.com/pQtUU2X.png)8F#.E6.AD.A5.E9.95.BF.E5.BA.8F.E5.88.97">维基百科</a>上查阅。<br>当前比较优秀的步长序列有：</p><ol><li>已知的最好步长序列是由Sedgewick提出的(1, 5, 19, 41, 109,…)，该序列的项来自<img src="http://i.imgur.com/flXbu1q.png">这两个算式。这项研究也表明“比较在希尔排序中是最主要的操作，而不是交换。”用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</li><li>另一个在大数组中表现优异的步长序列是（斐波那契数列除去0和1将剩余的数以黄金分区比的两倍的幂进行运算得到的数列）：(1, 9, 34, 182, 836, 4025, 19001, 90358, 428481, 2034035, 9651787, 45806244, 217378076, 1031612713,…)</li></ol><hr><h1 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h1><h2 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h2><p>直接选择排序和直接插入排序类似，都将数据分为有序区和无序区，所不同的是直接插入排序是将无序区的第一个元素直接插入到有序区以形成一个更大的有序区，而直接选择排序是从无序区选一个最小的元素直接放到有序区的最后。</p><p>步骤</p><ol><li>在给定的数组中找到最小(大)的元素，将其放置为数组的首位作为已排序区域。</li><li>继续在剩下的数组区域中寻找最小(大)的元素，放置到已排序区域的后边。</li><li>重复2步知道剩下的元素排序完毕。</li></ol><p>动图示例：</p><p><img src="http://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif"></p><h2 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">select_sort</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(array)):</span><br><span class="line">        min_index = i</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i + <span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">            <span class="keyword">if</span> array[j] &lt; array[min_index]:</span><br><span class="line">                min_index = j</span><br><span class="line">        array[min_index], array[i] = array[i], array[min_index]</span><br><span class="line"><span class="keyword">return</span> array</span><br></pre></td></tr></table></figure><hr><h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。它的思想就是先<code>递归分解</code>数组，再<code>合并</code>数组。</p><p>首先是合并两个数组。思路如下：比较两个数组的最前面的数字，取小的那个，取了之后就要从原来的数组中删除这个数字。 然后继续比较，知道一个数组为空，最后把另一个数组的剩余部分复制过来即可。</p><p>再者考虑递归分解。思路如下：将数组分为<code>left</code>和<code>right</code>，如果这两个数组内部有序，就合并这两个数组。确定两个数组内部有序的方法是，持续二分，知道每个小组中只有一个数字，此时该小组就认为有序。然后合并相邻两个小组。</p><p>动图演示：</p><p><img src="http://i.imgur.com/F7EZKVG.gif"></p><h2 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">merge_array</span>(<span class="params">array1, array2</span>):</span><br><span class="line">    left_index = right_index = <span class="number">0</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="comment"># 循环比较两个数组，知道某个数组为空</span></span><br><span class="line">    <span class="keyword">while</span> <span class="built_in">len</span>(array1) &gt; left_index <span class="keyword">and</span> <span class="built_in">len</span>(array2) &gt; right_index:</span><br><span class="line">        <span class="keyword">if</span> array1[left_index] &lt; array2[right_index]:</span><br><span class="line">            result.append(array1[left_index])</span><br><span class="line">            left_index += <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            result.append(array2[right_index])</span><br><span class="line">            right_index += <span class="number">1</span></span><br><span class="line">    <span class="comment"># 将不为空数组剩下的数字依次加入到结果列表中。另一个是空列表，所以可以这样实现。</span></span><br><span class="line">    result += array1[left_index:]</span><br><span class="line">    result += array2[right_index:]</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">divide_array</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="comment"># 结束条件</span></span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line"></span><br><span class="line">    index = <span class="built_in">len</span>(array) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    left = divide_array(array[:index])  <span class="comment"># 左半部分</span></span><br><span class="line">    right = divide_array(array[index:])  <span class="comment"># 右半部分</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> merge_array(left, right)</span><br></pre></td></tr></table></figure><hr><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><p>快速排序通常明显比同为Ο(n log n)的其他算法更快，因此常被采用，而且快排采用了<code>分治法</code>的思想，所以在很多笔试面试中能经常看到快排的影子。可见掌握快排的重要性。</p><p>步骤</p><ol><li>先从数列中取出一个数作为基准数。</li><li>分区过程，将比这个数大的数全放到它的右边，小于或等于它的数全放到它的左边。</li><li>再对左右区间重复第二步，直到各区间只有一个数</li></ol><p>动图示例：</p><p><img src="http://i.imgur.com/H2HyJ4p.gif"></p><h2 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort_simple</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    key = array[<span class="number">0</span>]</span><br><span class="line">    less, greater = [], []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="built_in">len</span>(array)):</span><br><span class="line">        <span class="keyword">if</span> array[i] &gt; key:</span><br><span class="line">            greater.append(array[i])</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            less.append(array[i])</span><br><span class="line">    <span class="keyword">return</span> quick_sort_simple(less) + [key] + quick_sort_simple(greater)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用列表推导式实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort_nic</span>(<span class="params">array</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="built_in">len</span>(array) &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> array</span><br><span class="line">    <span class="keyword">return</span> quick_sort_nic([x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x &lt; array[<span class="number">0</span>]]) + [x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x == array[<span class="number">0</span>]] + quick_sort_nic([x <span class="keyword">for</span> x <span class="keyword">in</span> array <span class="keyword">if</span> x &gt; array[<span class="number">0</span>]])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不开辟空间实现</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">quick_sort</span>(<span class="params">ary</span>):</span><br><span class="line">    <span class="keyword">return</span> qsort(ary,<span class="number">0</span>,<span class="built_in">len</span>(ary)-<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">qsort</span>(<span class="params">ary,left,right</span>):</span><br><span class="line">    <span class="comment">#快排函数，ary为待排序数组，left为待排序的左边界，right为右边界</span></span><br><span class="line">    <span class="keyword">if</span> left &gt;= right : <span class="keyword">return</span> ary</span><br><span class="line">    key = ary[left]     <span class="comment">#取最左边的为基准数</span></span><br><span class="line">    lp = left           <span class="comment">#左指针</span></span><br><span class="line">    rp = right          <span class="comment">#右指针</span></span><br><span class="line">    <span class="keyword">while</span> lp &lt; rp :</span><br><span class="line">        <span class="keyword">while</span> ary[rp] &gt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            rp -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> ary[lp] &lt;= key <span class="keyword">and</span> lp &lt; rp :</span><br><span class="line">            lp += <span class="number">1</span></span><br><span class="line">        ary[lp],ary[rp] = ary[rp],ary[lp]</span><br><span class="line">    ary[left],ary[lp] = ary[lp],ary[left]</span><br><span class="line">    qsort(ary,left,lp-<span class="number">1</span>)</span><br><span class="line">    qsort(ary,rp+<span class="number">1</span>,right)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br></pre></td></tr></table></figure><hr><h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><h2 id="原理-6"><a href="#原理-6" class="headerlink" title="原理"></a>原理</h2><p>堆排序与快速排序，归并排序一样都是时间复杂度为O(N*logN)的几种常见排序方法，</p><p>首先我们要理解数据结构中的二叉堆。具体介绍请移步文章<a href="http://lkhardy.cn/2017/08/15/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E5%A0%86/">数据结构之堆</a>。</p><p>我们知道二叉堆的两大性质：  </p><ol><li>父节点的键值总是大于或者等于任何一个子节点的键值。</li><li>每个节点的左右子树都是一个二叉树堆(都是最大堆或者是最小堆)</li></ol><p>步骤</p><ol><li><p>构建最大堆(Build_Max_Heap):若数组下标范围为0~n，考虑到单独一个元素的大根堆，则从下标<code>n/2</code>开始的元素均为大根堆。于是只要从<code>n/2-1</code>开始，向前依次构造大根堆，这样就保证，构造到某结点时，它的左右子树都已经是大根堆。</p></li><li><p>堆排序(HeapSort):由于堆是用数组模拟的。得到一个大根堆后，数组内部并不是有序的。因此需要将堆化数组有序化。 这种操作的思想是：移除根节点，并做最大堆调整的递归运算。第一次将<code>heap[0]</code>与<code>heap[n-1]</code>交换，再对<code>heap[0...n-2]</code>做最大堆调整。第二次将<code>heap[0]</code>与<code>heap[n-2]</code>交换，再对heap[0..n-3]做最大堆调整。重复该操作直至<code>heap[0]</code>和<code>heap[1]</code>交换。由于每次都是将最大的数字并入到后边的有序区间。所以操作完成时，整个数组就是有序的了。</p></li><li><p>最大堆调整(Max_Heapify)：该方法是被调用的，目的是将堆的末端子结点作调整。使得子结点永远小于父节点。</p></li></ol><p>动图演示：</p><p><img src="http://i.imgur.com/QgGdS7K.gif"></p><h2 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">heap_sort</span>(<span class="params">ary</span>):</span><br><span class="line">    n = <span class="built_in">len</span>(ary)</span><br><span class="line">    first = <span class="built_in">int</span>(n / <span class="number">2</span> - <span class="number">1</span>)  <span class="comment"># 最后一个非叶子节点</span></span><br><span class="line">    <span class="keyword">for</span> start <span class="keyword">in</span> <span class="built_in">range</span>(first, -<span class="number">1</span>, -<span class="number">1</span>):  <span class="comment"># 构造大根堆</span></span><br><span class="line">        max_heapify(ary, start, n - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> <span class="built_in">range</span>(n - <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>):  <span class="comment"># 堆排，将大根堆转换成有序数组</span></span><br><span class="line">        ary[end], ary[<span class="number">0</span>] = ary[<span class="number">0</span>], ary[end]</span><br><span class="line">        max_heapify(ary, <span class="number">0</span>, end - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> ary</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 最大堆调整：将堆的末端子节点作调整，使得子节点永远小于父节点</span></span><br><span class="line"><span class="comment"># start为当前需要调整最大堆的位置，end为调整边界</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">max_heapify</span>(<span class="params">ary, start, end</span>):</span><br><span class="line">    root = start</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        child = root * <span class="number">2</span> + <span class="number">1</span>  <span class="comment"># 调整节点的子节点</span></span><br><span class="line">        <span class="keyword">if</span> child &gt; end:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">if</span> child + <span class="number">1</span> &lt;= end <span class="keyword">and</span> ary[child] &lt; ary[child + <span class="number">1</span>]:</span><br><span class="line">            child = child + <span class="number">1</span>  <span class="comment"># 取较大的子节点</span></span><br><span class="line">        <span class="keyword">if</span> ary[root] &lt; ary[child]:  <span class="comment"># 较大的子节点成为父节点</span></span><br><span class="line">            ary[root], ary[child] = ary[child], ary[root]  <span class="comment"># 交换</span></span><br><span class="line">            root = child</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure><hr><p>相关代码都放置在了我的<a href="https://github.com/MerleLK/python-demo-small/tree/master/myAlgorithms/sort_demos">github</a></p><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ol><li><a href="http://blog.csdn.net/morewindows/article/category/859207">http://blog.csdn.net/morewindows/article/category/859207</a></li><li><a href="http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/">http://wuchong.me/blog/2014/02/09/algorithm-sort-summary/</a></li><li><a href="https://visualgo.net/zh/sorting">https://visualgo.net/zh/sorting</a></li></ol>]]></content>
    
    
    <summary type="html">常见的排序算法一</summary>
    
    
    
    <category term="algorithm" scheme="https://blog.lkhardy.cn/categories/algorithm/"/>
    
    <category term="sort" scheme="https://blog.lkhardy.cn/categories/algorithm/sort/"/>
    
    
    <category term="algorithm" scheme="https://blog.lkhardy.cn/tags/algorithm/"/>
    
    <category term="sort" scheme="https://blog.lkhardy.cn/tags/sort/"/>
    
  </entry>
  
  <entry>
    <title>链表-单链表</title>
    <link href="https://blog.lkhardy.cn/2017/08/02/alg-data-structure-single-linked-list/"/>
    <id>https://blog.lkhardy.cn/2017/08/02/alg-data-structure-single-linked-list/</id>
    <published>2017-08-02T14:14:29.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>线性表实现的基本需要：</p><ul><li>能够找到表中的首元素（无论直接或间接，通常很容易做到）    </li><li>从表里的任一个元素出发，可以找到它之后的下一个元素</li></ul><p>实现线性表的一种方式是基于链接结构，用链接显式地表示元素之间的顺序关联。<br>基于链接技术实现的线性表称为链接表或链表</p><p>而链表有存在单向链表和双向链表，今天我们先介绍以下单向链表(单链表)</p><h1 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h1><p>链表的单元是节点 <code>Node</code></p><ul><li>每个结点（对象）有自己的标识（下面也常直接称其为链接）</li><li>结点之间通过结点链接建立起顺序联系</li><li>给表的最后一个结点（表尾结点）的链接域设置一个不会作为结点<br>对象标识的值（Python 里自然应该用 None），称为空链接</li></ul><h2 id="简单的节点实现代码："><a href="#简单的节点实现代码：" class="headerlink" title="简单的节点实现代码："></a>简单的节点实现代码：</h2><pre><code>class Node(object):    def __init__(self, x, nxt):        self.val = x        self.next = nxt</code></pre><h1 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h1><p>对单链表的基本操作有：</p><p>1.创建空链表:对于链表而言只需要将表头变量设置为空链接  </p><blockquote><p>在Python中我们将其设置为None即可</p></blockquote><p>2.删除链表:丢弃表的所有节点  </p><blockquote><p>在python中我们只需要简单的将表指针设为None，就丢掉了整个链表的所有节点，Python的存储管理系统会自动回收掉不用的存储。</p></blockquote><p>3.判断链表是否为空: 将表头变量的值与空链接进行比较</p><blockquote><p>在Python中我们只需要检查其值是否为None即可</p></blockquote><p>4.判断链表是否满</p><blockquote><p>链表不会满， 除非存储空间全部用完</p></blockquote><p>5.首端加入元素</p><blockquote><p>1）创建一个新结点存入数据<br>2）把原链表首节点的连接存入新结点的链接域<br>3) 修改表头变量使之引用新结点  </p></blockquote><p>6.尾端加入元素</p><blockquote><ol><li>创建一个新结点存入数据  </li><li>表空时直接让表头变量引用这个新结点并结束，否则找到表尾结点  </li><li>令表尾结点的链接域引用这一新结点，并将新结点的链接域设置为空链接</li></ol></blockquote><p>7.定位加入元素</p><blockquote><ol><li>找到新结点加入位置的前一结点，不存在时结束  </li><li>创建新结点存入数据  </li><li>修改前一结点和新结点的链接域将结点连入</li></ol></blockquote><p>8.首端删除元素</p><blockquote><p>直接修改表头指针，使之引用当时表头结点的下一个结点。<br>Python 系统里会自动回收无用对象的存储块，下同</p></blockquote><p>9.尾端删除元素</p><blockquote><p>找到倒数第二个结点，将其链接域设置为空链接</p></blockquote><p>10.定位删除元素</p><blockquote><p>找到要删除元素所在结点的前一结点，修改它的链接域将<br>要求删除的结点从表中去掉</p></blockquote><h1 id="代码定义"><a href="#代码定义" class="headerlink" title="代码定义"></a>代码定义</h1><h2 id="普通单链表"><a href="#普通单链表" class="headerlink" title="普通单链表"></a>普通单链表</h2><pre><code># 单向链表class SinglyLinkedList(object):    def __init__(self):        self.head = None    # 判空只需要判断指向的下一个节点是否为None    def is_empty(self):        return self.head is None    # 链表首端加入新元素    def prepend(self, element):        self.head = Node(element, self.head)    # 尾端加入新元素    def append(self, element):        # 判断是否为空链表, 是就直接添加        if self.head is None:            self.head = Node(element, None)            return        # 链表不为空, 遍历得到表里最后一个节点, 然后用这个节点的next域记录新结点的链接        p = self.head        while p.next is not None:            p = p.next        p.next = Node(element, None)    # 首端弹出元素    def pop(self):        if self.head is None:            raise ValueError        value = self.head.val        self.head = self.head.next        return value    # 弹出尾端元素    def pop_last(self):        # 首先判断是否为空链表        if self.head is None:            raise ValueError        p = self.head        # 如果链表只有一个元素        if p.next is None:            value = p.val            self.head = None            return value        # 遍历链表 直到找到最后一个节点, 将前一个节点的next置为None        while p.next.next is not None:            p = p.next        value = p.next.val        p.next = None        return value    # 查找元素    def find(self, element):        p = self.head        while p is not None:            if element == p.val:                return p.next.val            p = p.next        return None    # 打印出所有元素    def print_all(self):        p = self.head        while p is not None:            print(p.val, end=&quot;&quot;)            p = p.next        print(&quot;&quot;)</code></pre><h2 id="带有尾结点的单链表"><a href="#带有尾结点的单链表" class="headerlink" title="带有尾结点的单链表"></a>带有尾结点的单链表</h2><pre><code># 带尾结点引用的单链表  尾结点引用---&gt;即指向最后一个节点# 较之上一个实现, 有效的解决了尾端插入的效率问题class SinglyLinkedListWithRearReference(SinglyLinkedList):    def __init__(self):        SinglyLinkedList.__init__(self)        self.rear = None    # 首端加入新元素    def prepend(self, element):        # 如果为空列表, 就将将元素置为第一个,并将尾节点引用指向当前节点        self.head = Node(element, self.head)        if self.rear is None:            self.rear = self.head    # 尾端加入新元素    def append(self, element):        if self.head is None:            # 直接调用首端加入, 对于第一个元素, 加入都是一致的            self.prepend(element)        else:            # 尾端加入新的元素时, 将尾结点引用指向当前新加入的节点            self.rear.next = Node(element, None)            self.rear = self.rear.next    # 从首端删除元素    def pop(self):        if self.head is None:            raise ValueError        value = self.head.val        # 如果尾结点引用指向了头结点, 那么说明 当前链表只有一个元素节点, 删除之后需要将尾结点引用置为None        if self.rear is self.head:            self.rear = None        # 将链表的头指向下一个元素节点        self.head = self.head.next        return value    # 从尾端删除元素    def pop_last(self):        if self.head is None:            raise ValueError        val = self.rear.val        p = self.head        while p.next.val != val:            p = p.next        p.next = None        self.rear = p</code></pre><h2 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h2><pre><code># 循环单链表  不必要使用单链表为基类class CircularSinglyLinkedList(object):    def __init__(self):        self.rear = None    # 判断是否为空    def is_empty(self):        return self.rear is None    # 首端加入新元素    def prepend(self, element):        p = Node(element, None)        # 如果是空链表，就要建立初始的循环链接， 即自己链接自己        if self.rear is None:            p.next = p            self.rear = p        # 链表不空，就要链接在尾结点之后， 就是首结点        else:            p.next = self.rear.next  # 先将原来的首结点链接在自己的后边            self.rear.next = p  # 自己成为首结点    # 尾端加入新元素    def append(self, element):        # 直接调用之前的加入操作        self.prepend(element)        # 将尾节点置换为新加入的结点        self.rear = self.rear.next    # 删除首端元素    def pop(self):        # 首先判断是否为空列表        if self.rear is None:            raise ValueError        p = self.rear.next        # 如果尾节点指向自己，说明只有一个结点， 弹出结点之后 将尾节点置空        if self.rear is p:            self.rear = None        # 正常情况下，删除首结点，并将首结点置为原来首结点的下一个        else:            self.rear.next = p.next        return p.val    # 删除尾端元素    def pop_last(self):        # 首先判断是否为空列表        if self.rear is None:            raise ValueError        p = self.rear.next        if p is self.rear:            self.rear = None            return p.val        while p.next is not self.rear:            p = p.next        p.next = self.rear.next        self.rear = p        return p.val    # 遍历所有结点    def print_all(self):        p = self.rear.next        while True:            print(p.val, end=&quot;&quot;)            if p is self.rear:                print(&quot;&quot;)                break            p = p.next</code></pre><h1 id="常见操作"><a href="#常见操作" class="headerlink" title="常见操作"></a>常见操作</h1><pre><code>from data_structure.link_list.singly_linked_list import SinglyLinkedList# 反序链表def reverse_by_singly(my_list):    &quot;&quot;&quot;    使用修改链接关系：    1如果一直向首端添加结点，最先进去的就会在尾结点    2一直从首端取元素，最后得到的时尾结点。    这样就可以实现反转算法了    :param my_list: 被操作的链表    :return: 无    &quot;&quot;&quot;    p = None    while my_list.head is not None:        q = my_list.head        my_list.head = q.next        q.next = p        p = q    my_list.head = p# 基于移动元素的单链表排序def sort_linked_list_by_move_value(my_list):    &quot;&quot;&quot;    为了有效实现，算法只能从头到尾方向检查和处理。    每次拿出一个元素，在已排序的序列中找到正确位置插入    :param my_list: 被操作的链表    :return: 无    &quot;&quot;&quot;    if my_list.head is None:        return    crt = my_list.head.next  # 计算从首结点之后开始，即首结点已排序完毕    while crt is not None:        x = crt.val        p = my_list.head        # 从原链表的首结点开始进行比较，存在如下情况        # 1. 当前结点的值大于已排序完毕的结点，跳过        while p is not crt and p.val &lt;= x:            p = p.next        # 2. 当前结点的值小于已排序完毕的结点， 交换元素位置        while p is not crt:            x, p.val = p.val, x            p = p.next        crt.val = x        crt = crt.next# 基于调整链接关系实现排序工作def sort_linked_list_by_change_relation(my_list):    &quot;&quot;&quot;    基本处理模式与移动元素类似.    但是这里不在结点之间移动表元素，而是把被处理的结点取下来接到正确的位置上。    :param my_list: 被操作的链表    :return: 无    &quot;&quot;&quot;    # 判断链表是否为空    if my_list.head is None:        return    # 初始 已排序的段只有一个结点    last = my_list.head  # 表示已排序段的尾结点    crt = last.next      # 待排序段的首结点    # 顺序链表的结点，每次处理一个结点    while crt is not None:        # 设置扫描指针的初始值        p = my_list.head  # 已排序，并且比较完毕的段        q = None  # 已排序但为比较完毕的段        while p is not crt and p.val &lt;= crt.val:            # 顺序更新两个扫描指针            q = p            p = p.next        # 当 p 是 crt 时 不需要修改链接，设置last到下一个结点crt        if p is crt:            last = crt        else:            # 取出当前结点            last.next = crt.next            # 接好后置链接            crt.next = p            if q is None:                # 作为新的首结点                my_list.head = crt            else:                # 接在表中间                q.next = crt        # crt 指向last的下一个结点        crt = last.next</code></pre><h2 id="Josephus-问题"><a href="#Josephus-问题" class="headerlink" title="Josephus 问题"></a>Josephus 问题</h2><p>使用循环单链表解决：</p><pre><code>&quot;&quot;&quot;@description: 经典问题 Josephus问题@author: merleLK@contact: merle.liukun@gmail.com@date: 17-8-2@detail: 问题描述：    设有n个人围坐一圈，现在从第k个人开始报数，报到第m的人退出。    然后继续报数，直至所有人退出。输出出列人顺序编号。&quot;&quot;&quot;from data_structure.link_list.singly_linked_list import CircularSinglyLinkedList# 基于list和固定大小的数组def josephus_list(n, k, m):    &quot;&quot;&quot;    1.建立一个包含n个人（编号）的list    2.找到k个人， 从那里开始        处理过程中，把对应的表元素修改为0表示人已经退出    3.反复操作：        数m个（在席）人        把表示第m个人的元素修改为0    Tips: 数到list最后元素之后转到下标为0的元素继续    :param n: 列表的长度    :param k: 开始位置    :param m: 退出条件    :return: 无    &quot;&quot;&quot;    people = list(range(1, n + 1))    print(people)    i = k - 1  # 开始位置的下标    for num in range(n):        count = 0  # 报数编号        # 一次循环最多到m， 此时就会把最后一个人踢出        while count &lt; m:            if people[i] &gt; 0:                count += 1            if count == m:                print(people[i], end=&quot;&quot;)                people[i] = 0            i = (i + 1) % n  # 遍历到最后一个位置就会从首位再次开始        print(&quot;,&quot; if num &lt; n - 1 else &quot;\n&quot;, end=&quot;&quot;)def josephus_list_pop(n, k, m):    &quot;&quot;&quot;    1.算出应该退出的元素之后, 将其从表中删除    2.直至表长度为0的时候结束    复杂度： O(n^2)    :param n: 列表的长度    :param k: 开始位置    :param m: 退出条件    :return: 无    &quot;&quot;&quot;    people = list(range(1, n + 1))    i = k - 1    for num in range(n, 0, -1):        i = (i + int(m) - 1) % num        print(people.pop(i), end=&quot;&quot;)        print(&quot;,&quot; if num &gt; 1 else &quot;\n&quot;, end=&quot;&quot;)class JosephusLinkedList(CircularSinglyLinkedList):    &quot;&quot;&quot;    1.从形式看，循环单链表很好地表现了围坐一圈的人    2.顺序的数人头，很好的符合了循环表中沿着next链扫描    3.某人退出之后，删除相应结点，之后可以继续沿着原来的方向数人头    算法复杂度 O(m*n)    &quot;&quot;&quot;    def __init__(self, n, k, m):        CircularSinglyLinkedList.__init__(self)        # 创建包含n个元素的循环链表        for i in range(n):            self.append(i + 1)        # 将初始结点移动到k处        self.turn(k - 1)        # 循环弹出第m个元素直到链表为空        while not self.is_empty():            self.turn(m - 1)            print(self.pop(), end=&quot;&quot;)            print(&quot;,&quot; if self.rear is not None else &quot;\n&quot;, end=&quot;&quot;)    # 将循环表对象的rear指针沿着next移动了m步    def turn(self, m):        for i in range(m):            self.rear = self.rear.nextif __name__ == &#39;__main__&#39;:    josephus_list(10, 2, 7)    josephus_list_pop(10, 2, 7)    JosephusLinkedList(10, 2, 7)</code></pre><p>源代码已经放置于我的 <a href="https://github.com/MerleLK/python-demo-small/tree/master/data_structure/link_list">github</a>.</p>]]></content>
    
    
    <summary type="html">链表-单链表</summary>
    
    
    
    <category term="数据结构" scheme="https://blog.lkhardy.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="链表" scheme="https://blog.lkhardy.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E9%93%BE%E8%A1%A8/"/>
    
    
    <category term="数据结构" scheme="https://blog.lkhardy.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="链表" scheme="https://blog.lkhardy.cn/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 遍历对象的方法</title>
    <link href="https://blog.lkhardy.cn/2017/07/26/front-js-object-loop/"/>
    <id>https://blog.lkhardy.cn/2017/07/26/front-js-object-loop/</id>
    <published>2017-07-26T15:48:57.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h1 id="有关对象遍历的几个方法"><a href="#有关对象遍历的几个方法" class="headerlink" title="有关对象遍历的几个方法"></a>有关对象遍历的几个方法</h1><p>所有继承到<code>Object</code>的对象都会继承到<code>hasOwnProerty()</code>方法，此方法用来检测一个对象是否包含特定的自身属性，其与<code>in</code>运算符不同之处在于，<code>hasOwnProperty</code>方法会忽略掉那些从原型链上继承到的属性。</p><p>1.一个简单的例子： 检测对象obj是否含有自身属性’prop’.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">obj = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">obj.<span class="property">prop</span> = <span class="string">&#x27;exists&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">changeO</span>(<span class="params"></span>)&#123;  <span class="comment">// 将prop属性删除。</span></span><br><span class="line">    obj.<span class="property">newprop</span> = obj.<span class="property">prop</span>;</span><br><span class="line">    <span class="keyword">delete</span> obj.<span class="property">prop</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;prop&#x27;</span>));  <span class="comment">// True</span></span><br><span class="line"><span class="title function_">changeO</span>();</span><br><span class="line"><span class="title function_">alert</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;prop&#x27;</span>));  <span class="comment">// False</span></span><br></pre></td></tr></table></figure><p>对于从原型链上继承的属性，<code>hasOwnProperty</code>方法会将其忽略。而<code>in</code>操作符则是将原型链上的属性也涵盖。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">alert</span>(obj.<span class="title function_">hasOwnProperty</span>(<span class="string">&#x27;toString&#x27;</span>));  <span class="comment">// False</span></span><br><span class="line"><span class="title function_">alert</span>(<span class="string">&#x27;toString&#x27;</span> <span class="keyword">in</span> obj);   <span class="comment">// True</span></span><br></pre></td></tr></table></figure><p>2.遍历一个对象所有的自身属性。忽略掉继承属性。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> buz = &#123;</span><br><span class="line">    <span class="attr">fog</span>: <span class="string">&#x27;stack&#x27;</span>,</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;hello&#x27;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> name <span class="keyword">in</span> buz) &#123;</span><br><span class="line">    <span class="keyword">if</span> (buz.<span class="title function_">hasOwnProperty</span>(name)) &#123;</span><br><span class="line">        <span class="title function_">alert</span>(<span class="string">&quot;this is fog (&quot;</span> + name + <span class="string">&quot;) for sure. Value: &quot;</span> + buz[name]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="title function_">alert</span>(name); <span class="comment">// toString or something else</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意： 此例子中<code>for...in</code>循环只会遍历可枚举的属性。</p><p>3.处理json对象转为字符串。</p><p>我们需要遍历一个json对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">&#x27;&#123;&quot;data&quot;:[&#123;&quot;d1&quot;: &quot;c1&quot;, &quot;d2&quot;: &quot;c2&quot;&#125;]&#125;&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> parsedData = <span class="title class_">JSON</span>.<span class="title function_">parse</span>(s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> parserd_data)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> j <span class="keyword">in</span> parserd_data[i])&#123;</span><br><span class="line">        <span class="title function_">alert</span>(parserd_data[i][j]);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(parserd_data[i][j]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> parserd_data[i][j])&#123;</span><br><span class="line">            <span class="title function_">alert</span>(parserd_data[i][j][k]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法有些费劲，所以可以定义一个函数进行遍历,虽然函数很长，但是对基本的情况也进行了校验，没有使用那么多的嵌套循环。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">JsonToStr</span>(<span class="params">data</span>)&#123;</span><br><span class="line">    <span class="keyword">var</span> resultStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> data)&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.<span class="title function_">hasOwnProperty</span>(i))&#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="title function_">typeof</span>(data[i]) === <span class="string">&quot;object&quot;</span>)&#123;</span><br><span class="line">                <span class="title class_">JsonToStr</span>(data[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(resultStr === <span class="string">&quot;&quot;</span>)&#123;</span><br><span class="line">                    resultStr = i + <span class="string">&quot;,&quot;</span> + data[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    resultStr = resultStr + <span class="string">&quot;,&quot;</span> + i + <span class="string">&quot;,&quot;</span> + data[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> resultStr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><ul><li><a href="https://developer.mozilla.org/zh-CN/">MDN web docs</a></li></ul>]]></content>
    
    
    <summary type="html">JavaScript 遍历对象的方法</summary>
    
    
    
    <category term="JavaScript" scheme="https://blog.lkhardy.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://blog.lkhardy.cn/tags/JavaScript/"/>
    
    <category term="object" scheme="https://blog.lkhardy.cn/tags/object/"/>
    
  </entry>
  
  <entry>
    <title>JavaScrip 基本数据类型的常用操作</title>
    <link href="https://blog.lkhardy.cn/2017/07/25/front-js-datatype-common/"/>
    <id>https://blog.lkhardy.cn/2017/07/25/front-js-datatype-common/</id>
    <published>2017-07-25T14:41:38.000Z</published>
    <updated>2023-01-04T02:36:33.138Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>在日常项目中，发现会经常用到JS基本数据类型相关的一些操作。经常是当场搜索相关的用法。还是不利于自己学习。所以还是记录以下，增加自己的记忆。</p><h1 id="字符串相关"><a href="#字符串相关" class="headerlink" title="字符串相关"></a>字符串相关</h1><h2 id="移除字符串中某些特定的字符"><a href="#移除字符串中某些特定的字符" class="headerlink" title="移除字符串中某些特定的字符"></a>移除字符串中某些特定的字符</h2><p>使用<code>replace()</code>函数替换，去除myStr字符串中的, : ; = ‘[ ] ‘ + 等符号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myStr = <span class="string">&quot;123,abc:456;abc=abc[]&quot;</span>;</span><br><span class="line">myStr.<span class="title function_">replace</span>(<span class="regexp">/[,:;=\[\]]+/g</span>,<span class="string">&#x27;&#x27;</span>);</span><br><span class="line"><span class="comment">// Output: &quot;123abc456abcabc&quot;</span></span><br></pre></td></tr></table></figure><p>使用<code>split()</code>和<code>join()</code>函数，去掉冒号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString = <span class="string">&quot;12:30:21&quot;</span></span><br><span class="line">myString.<span class="title function_">split</span>(<span class="string">&quot;:&quot;</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// Output: &quot;123021&quot;</span></span><br></pre></td></tr></table></figure><p>去除myStr字符串中的, : ; = ‘[ ] ‘ + 等符号</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myStr = <span class="string">&quot;123,abc:456;abc=abc[]&quot;</span>;</span><br><span class="line">my_str.<span class="title function_">split</span>(<span class="regexp">/[,:;]/</span>).<span class="title function_">join</span>(<span class="string">&quot;&quot;</span>)</span><br><span class="line"><span class="comment">// Output: &quot;123abc456abc=abc[]&quot;</span></span><br></pre></td></tr></table></figure><p>以上两种方法都使用了正则表达式进行处理。</p><h2 id="删除字符串最后一个字符"><a href="#删除字符串最后一个字符" class="headerlink" title="删除字符串最后一个字符"></a>删除字符串最后一个字符</h2><p>使用<code>substring()</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString = <span class="string">&quot;1,2,3,4,&quot;</span></span><br><span class="line">myString.<span class="title function_">substring</span>(<span class="number">0</span>, s.<span class="property">length</span>-<span class="number">1</span>) </span><br><span class="line"><span class="comment">// output: &quot;1,2,3,4&quot;</span></span><br></pre></td></tr></table></figure><p><code>substring(start, end)</code> 函数，经常用于提取一个字符串中下标在 <code>[start, end)</code> 之间的子字符串。包含 <code>start</code>,不包含 <code>end</code>。</p><ul><li>如果 start 与 end 相等，那么该方法返回的就是一个空串（即长度为 0 的字符串）。</li><li>如果 start 比 end 大，那么该方法在提取子串之前会先交换这两个参数。</li><li>如果 start 或 end 为负数，那么它将被替换为 0。</li></ul><h2 id="获取字符串中子字符串"><a href="#获取字符串中子字符串" class="headerlink" title="获取字符串中子字符串"></a>获取字符串中子字符串</h2><p>使用 <code>substring()</code> 函数，但需要指定下标。</p><p>使用<code>substr()</code>函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myString = <span class="string">&quot;0123456789&quot;</span></span><br><span class="line"><span class="comment">// 获取从第6位开始的所有剩余字符, 下标从0开始</span></span><br><span class="line">myString.<span class="title function_">substr</span>(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// Output: 56789</span></span><br></pre></td></tr></table></figure><p><code>substr(start, length)</code> 函数，用于返回一个从指定位置开始的指定长度的子字符串。</p><p>参数说明</p><ul><li>start  必须要有，所需字符串的起始位置。</li><li>length  可选，返回的字符串中应包含字符的个数</li><li>如果start为负数，那么start=str.length+start</li><li>如果length为0或者负数，就会返回一个空字符串</li><li>如果不指定length参数，则字符串就会一直到str的末尾</li></ul><h2 id="判断字符串是否在另一个字符串中"><a href="#判断字符串是否在另一个字符串中" class="headerlink" title="判断字符串是否在另一个字符串中"></a>判断字符串是否在另一个字符串中</h2><p>使用 <code>indexof()</code> 函数</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fullStr = <span class="string">&#x27;helloWorld&#x27;</span>;</span><br><span class="line"><span class="keyword">if</span>(fulleStr.<span class="title function_">indexof</span>(<span class="string">&#x27;hello&#x27;</span>))&#123;</span><br><span class="line">    <span class="title function_">alert</span>(<span class="string">&#x27;fullStr has str hello&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fullStr.indexof(str)</code> 函数，用于返回 <code>String</code> 对象内第一次出现子字符串的字符位置。如果没有找到子字符串就会返回 <code>-1</code>。</p>]]></content>
    
    
    <summary type="html">JavaScrip 基本数据类型的常用操作</summary>
    
    
    
    <category term="JavaScript" scheme="https://blog.lkhardy.cn/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://blog.lkhardy.cn/tags/JavaScript/"/>
    
    <category term="data" scheme="https://blog.lkhardy.cn/tags/data/"/>
    
  </entry>
  
</feed>
